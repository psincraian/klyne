name: CD

on:
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types:
      - completed

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    
    environment: production
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Add servers to known hosts
      run: |
        # Get server IPs from Terraform outputs (assuming they're stored as secrets)
        # Alternative: parse from Terraform state or use a service discovery method
        
        # For now, we'll skip strict host key checking for deployment
        # In production, you should properly manage known_hosts
        mkdir -p ~/.ssh
        echo "StrictHostKeyChecking no" >> ~/.ssh/config
        echo "UserKnownHostsFile /dev/null" >> ~/.ssh/config
        chmod 600 ~/.ssh/config

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Get server IPs from Terraform
      id: terraform
      working-directory: ./deployment
      env:
        TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_domain_name: ${{ secrets.DOMAIN_NAME }}
        TF_VAR_resend_api_key: ${{ secrets.RESEND_API_KEY }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        terraform init -backend-config=backend.hcl
        
        # Check if infrastructure exists, if not create it
        if ! terraform show > /dev/null 2>&1; then
          echo "No existing infrastructure found, creating..."
          terraform plan -out=tfplan
          terraform apply tfplan
        fi
        
        # Get server IPs from Terraform state
        if terraform output server_ips > /dev/null 2>&1; then
          SERVER_IPS=$(terraform output -json server_ips | jq -r '.[]' | tr '\n' ' ')
          echo "server_ips=$SERVER_IPS" >> $GITHUB_OUTPUT
        else
          echo "‚ùå No server_ips output found. Infrastructure may not be deployed."
          exit 1
        fi
        
        # Get load balancer IP
        if terraform output load_balancer_ipv4 > /dev/null 2>&1; then
          LB_IP=$(terraform output -raw load_balancer_ipv4)
          echo "load_balancer_ip=$LB_IP" >> $GITHUB_OUTPUT
        else
          echo "‚ùå No load_balancer_ipv4 output found. Infrastructure may not be deployed."
          exit 1
        fi

    - name: Deploy to production
      env:
        SERVERS: ${{ steps.terraform.outputs.server_ips }}
        IMAGE_TAG: ${{ github.sha }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_ACTOR: ${{ github.actor }}
      run: |
        # Make deployment script executable
        chmod +x ./deployment/deploy.sh
        
        # Run deployment
        ./deployment/deploy.sh

    - name: Verify deployment
      env:
        LB_IP: ${{ steps.terraform.outputs.load_balancer_ip }}
        DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
      run: |
        # Test the application health through load balancer
        if [[ -n "$DOMAIN_NAME" ]]; then
          ENDPOINT="https://$DOMAIN_NAME"
        else
          ENDPOINT="http://$LB_IP"
        fi
        
        echo "Testing endpoint: $ENDPOINT"
        
        # Wait for deployment to settle
        sleep 30
        
        # Test health endpoint
        for i in {1..10}; do
          if curl -f -s "$ENDPOINT/health" | grep -q "healthy"; then
            echo "‚úÖ Deployment verification successful!"
            exit 0
          fi
          echo "‚è≥ Waiting for deployment to be ready... (attempt $i/10)"
          sleep 15
        done
        
        echo "‚ùå Deployment verification failed"
        exit 1

    - name: Notify deployment status
      if: always()
      run: |
        if [[ "${{ job.status }}" == "success" ]]; then
          echo "üöÄ Deployment to production completed successfully!"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        else
          echo "üí• Deployment to production failed!"
        fi

  rollback:
    if: ${{ failure() && github.event.workflow_run.conclusion == 'success' }}
    needs: deploy
    runs-on: ubuntu-latest
    
    environment: production
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Configure SSH
      run: |
        mkdir -p ~/.ssh
        echo "StrictHostKeyChecking no" >> ~/.ssh/config
        echo "UserKnownHostsFile /dev/null" >> ~/.ssh/config
        chmod 600 ~/.ssh/config

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Get server IPs
      id: terraform
      working-directory: ./deployment
      env:
        TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_domain_name: ${{ secrets.DOMAIN_NAME }}
        TF_VAR_resend_api_key: ${{ secrets.RESEND_API_KEY }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        terraform init -backend-config=backend.hcl
        
        # Get server IPs from Terraform state with error handling
        if terraform output server_ips > /dev/null 2>&1; then
          SERVER_IPS=$(terraform output -json server_ips | jq -r '.[]' | tr '\n' ' ')
          echo "server_ips=$SERVER_IPS" >> $GITHUB_OUTPUT
        else
          echo "‚ùå No server_ips output found. Cannot perform rollback."
          exit 1
        fi

    - name: Rollback deployment
      env:
        SERVERS: ${{ steps.terraform.outputs.server_ips }}
        IMAGE_TAG: latest  # Rollback to latest stable
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
        PREVIOUS_IMAGE_TAG: latest
      run: |
        echo "üîÑ Starting rollback procedure..."
        chmod +x ./deployment/deploy.sh
        ./deployment/deploy.sh || {
          echo "‚ùå Rollback failed! Manual intervention required."
          exit 1
        }
        echo "‚úÖ Rollback completed successfully!"